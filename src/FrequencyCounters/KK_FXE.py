# -*- coding: utf-8 -*-

import sys
import time

import numpy as np

from src.FrequencyCounters.kklib import (
    NativeLib,
    NativeLibError,
    FHRSettings,
    ErrorCode
)

from misc.rate import rate_values


outputPath = r"C:\Users\user\Desktop\FrequencyDriftStabilizer_latest\src\FrequencyCounters/Debug"

cmds_kk = {
    'control': {
        'version': bytes([0x01]),
        'reset': bytes([0x0A]),
        'sync enable': bytes([0x0F])
    },
    'rate': {
        '1ms': bytes([0x20]),
        '2ms': bytes([0x21]),
        '5ms': bytes([0x22]),
        '10ms': bytes([0x23]),
        '20ms': bytes([0x24]),
        '50ms': bytes([0x25]),
        '100ms': bytes([0x26]),
        '200ms': bytes([0x27]),
        '500ms': bytes([0x28]),
        '1s': bytes([0x29]),
        '2s': bytes([0x2A]),
        '5s': bytes([0x2B]),
        '10s': bytes([0x2C]),
        '20s': bytes([0x2D])
    },
    'channel': {
        'all': bytes([0x30]),
        '1': bytes([0x31]),
        '2': bytes([0x32]),
        '3': bytes([0x33]),
        '4': bytes([0x34])
    },
    'mode': {
        'phase': bytes([0x40]),
        'phase avg': bytes([0x41]),
        'frequency': bytes([0x42]),
        'frequency avg': bytes([0x43]),
        'phase diff': bytes([0x44]),
        'phase diff avg': bytes([0x45])
    },
    'scrambler': {
        'off': bytes([0x50]),
        'auto': bytes([0x5E]),
        'trim': bytes([0x5F])
    }
}

class FXEHandler():

    def __init__(self, conn):

        self._conn = conn
        self._channels = '1'

        self._rate = 0.1
        self._f = [0, 0]
        self._fAvg = 0

        self._flagConnected = False

        # ----- Initialisation -----
        # Loading K+K library
        try:
            # load K+K library
            self._kknative = NativeLib();
        except NativeLibError as exc:
            # stop execution
            sys.exit(str(exc))

        # get source ID
        self._source_id = self._kknative.get_source_id()

        # Output path for files generated by library
        self._path = outputPath

        kkres = self._kknative.set_output_path(self._source_id, self._path)
        if kkres.result_code != ErrorCode.KK_NO_ERR:
            print("set_output_path: unexpected Error", flush=True)
            print("set_output_path: "+kkres.data, flush=True)
        else:
            print("set_output_path: ok", flush=True)
        # check it
        kkres = self._kknative.get_output_path(self._source_id)
        if kkres.result_code != ErrorCode.KK_NO_ERR:
            print("get_output_path: unexpected Error", flush=True)
        print("get_output_path: "+kkres.data, flush=True)

        # set decimal separator to .
        kkres = self._kknative.set_decimal_separator(self._source_id, ".")
        if kkres.data != None:
            print("set decimal separator failed: "+kkres.data, flush=True)

        print('FXE handler initiated!', flush=True)

    def parseCommand(self, cmdDict):

        if cmdDict['cmd'] == 'rate':
            self._rate = rate_values[cmdDict['args']]
            self.send_command(cmds_kk['rate'][cmdDict['args']])
        elif cmdDict['cmd'] == 'channels':
            self.setChannels(cmdDict['args'])
        elif cmdDict['cmd'] == 'mode':
            if cmdDict['args'] == 'Phase':
                self.send_command(cmds_kk['mode']['frequency avg'])
            else: # includes mode == 'Frequency'
                self.send_command(cmds_kk['mode']['frequency avg'])
        elif cmdDict['cmd'] == 'devices':
            ret = self.enumerate_devices()
            self._conn.send({'dev': 'FC', 'cmd': 'devices', 'args': ret})
        elif cmdDict['cmd'] == 'connect':
            self.connect(cmdDict['args'])
            self._conn.send({'dev': 'FC', 'cmd': 'connection', 'args': self._flagConnected})
        elif cmdDict['cmd'] == 'disconnect':
            self.disconnect()
            self._conn.send({'dev': 'FC', 'cmd': 'connection', 'args': self._flagConnected})
    
    def fAvg(self):

        return self._fAvg

    def isConnected(self):

        if self._flagConnected:
            return True
        else:
            return False

    def setFreqTarget(self, fTarget):

        return True

    # Connection
    def enumerate_devices(self):

        kkres = self._kknative.enumerate_Devices(NativeLib.ENUM_FLAG_LOCAL_DEVICES)
 	
        if kkres.data is None:
            return []
        else:
            return [item.strip() for item in kkres.data.split(',')]
    
    def connect(self, address):

        if not self._flagConnected:
            # open connection
            blocking = True # False
            if address.startswith('/dev/tty'):
                address = '{}:115200'.format(address)
            print('Connecting to {}...'.format(address))
            kkres = self._kknative.open_connection(self._source_id, address, blocking)
            if kkres.result_code != ErrorCode.KK_NO_ERR:
                print('Could not connect to FXE frequency counter! Error code: {}'.format(kkres.result_code))
                self._flagConnected = False
                return False
            self._flagConnected = True
            print('Connected to FXE frequency counter!', flush=True)
            # set 2 channel mode
            self.send_command(cmds_kk['channel'][self._channels])
            # set frequency mode
            self.send_command(cmds_kk['mode']['frequency'])
            return True
        else:
            print('Already connected to FXE frequency counter!')
            return False

    def disconnect(self):

        if self._flagConnected:
            self._kknative.close_connection(self._source_id)
            self._flagConnected = False
            print('Frequency Counter disconnected!', flush=True)
            return True
        else:
            return False
    
    # Control
    def send_command(self, cmd):

        if self._flagConnected:
            kkres = self._kknative.send_command(self._source_id, cmd)
            if kkres.result_code != ErrorCode.KK_NO_ERR:
                print('Command failed!', flush=True)
                return False
            else:
                return True
        else:
            return False

    def setChannels(self, ch):

        self._channels = ch
        self.send_command(cmds_kk['channel'][self._channels])

    def read_buffer(self):

        if self._flagConnected:
            kkres = self._kknative.get_report(self._source_id)
            # examine result code
            if kkres.result_code == ErrorCode.KK_ERR_BUFFER_OVERFLOW:
                print("get_report reports overflow error", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_SERVER_DOWN:
                print("get_report reports no connection to TCP server", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_WRITE:
                print("get_report reports write error", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_DEVICE_NOT_CONNECTED:
                print("get_report reports unconnected device", flush=True)
            elif kkres.result_code == ErrorCode.KK_HARDWARE_FAULT:
                print("get_report reports hardware fault", flush=True)
            elif ((kkres.result_code != ErrorCode.KK_NO_ERR) and 
                (kkres.result_code != ErrorCode.KK_ERR_BUFFER_TOO_SMALL)):
                print("get_report failed: "+kkres.data, flush=True)
            elif kkres.data is None:
                print('No data', flush=True)

            else:
                #report header
                subS = kkres.data[:4]
                aHeader = int(subS, 16) # HEX!
                if aHeader < 0x7000:
                    ret = [item.strip() for item in kkres.data.split(';')]
                    ret[0] = aHeader
                    return ret
                elif aHeader > 0x7000:
                    ret = [item.strip() for item in kkres.data.split(';')]
                    ret[0] = aHeader
                    return ret
                # ignore empty message (7000)
                else:
                    return None

            return None
        else:
            return None

    # Measurement
    def measure(self):

        if not self._flagConnected:
            return False

        data = self.read_buffer()
        if data is not None:
            header = data[0]
            if header < 0x7000:
                try:
                    if self._channels == '1':
                        self._f[0] = float(data[1]) * 1e3
                        self._f[1] = float(data[1]) * 1e3
                    elif self._channels == '2':
                        self._f[0] = float(data[1]) * 1e3
                        self._f[1] = float(data[2]) * 1e3
                    self._fAvg = np.average(self._f)
                    self._conn.send({'dev': 'FC', 'cmd': 'data', 'args': self._f})
                    return True
                except ValueError:
                    return False
            else:
                # print(data, flush=True)
                return False
    
        return False
