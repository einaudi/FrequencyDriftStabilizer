# -*- coding: utf-8 -*-

import sys
import time

import numpy as np

from src.kklib import NativeLib, NativeLibError, FHRSettings
from src.kklib import ErrorCode

from misc.kk_commands import cmds, cmds_values


outputPath = r"/home/qgl/Desktop/KK_FXE/python/FXE_measure_GUI/Debug"


class FXEHandler():

    def __init__(self, q, conn):

        self._q = q
        self._conn = conn

        self._rate = 0.1
        self._f = [0, 0]

        self._flagConnected = False

        # ----- Initialisation -----
        # Loading K+K library
        try:
            # load K+K library
            self._kknative = NativeLib();
        except NativeLibError as exc:
            # stop execution
            sys.exit(str(exc))

        # get source ID
        self._source_id = self._kknative.get_source_id()

        # Output path for files generated by library
        self._path = outputPath

        kkres = self._kknative.set_output_path(self._source_id, self._path)
        if kkres.result_code != ErrorCode.KK_NO_ERR:
            print("set_output_path: unexpected Error", flush=True)
            print("set_output_path: "+kkres.data, flush=True)
        else:
            print("set_output_path: ok", flush=True)
        # check it
        kkres = self._kknative.get_output_path(self._source_id)
        if kkres.result_code != ErrorCode.KK_NO_ERR:
            print("get_output_path: unexpected Error", flush=True)
        print("get_output_path: "+kkres.data, flush=True)

        # set decimal separator to .
        kkres = self._kknative.set_decimal_separator(self._source_id, ".")
        if kkres.data != None:
            print("set decimal separator failed: "+kkres.data, flush=True)

        print('FXE handler initiated!', flush=True)

    def parseFXECommand(self, cmdDict):

        if cmdDict['cmd'] == 'command':
            self.send_command(cmdDict['args'])
        elif cmdDict['cmd'] == 'rate':
            self._rate = cmds_values['rate'][cmdDict['args']]
            self.send_command(cmds['rate'][cmdDict['args']])
            print('Rate changed to {}'.format(cmdDict['args']))
        elif cmdDict['cmd'] == 'mode':
            self.send_command(cmds['mode'][cmdDict['args']])
            print('Mode changed to {}'.format(cmdDict['args']))
        elif cmdDict['cmd'] == 'devices':
            ret = self.enumerate_devices()
            self._conn.send({'cmd': 'devices', 'args': ret})
        elif cmdDict['cmd'] == 'connect':
            self.connect(cmdDict['args'])
            self._conn.send({'cmd': 'connection', 'args': self._flagConnected})
        elif cmdDict['cmd'] == 'disconnect':
            self.disconnect()
            self._conn.send({'cmd': 'connection', 'args': self._flagConnected})

    def queueEmpty(self):

        return self._q.empty()
    
    # Connection
    def enumerate_devices(self):

        kkres = self._kknative.enumerate_Devices(NativeLib.ENUM_FLAG_LOCAL_DEVICES)
        
        return [item.strip() for item in kkres.data.split(',')]
    
    def connect(self, address):

        if not self._flagConnected:
            # open connection
            blocking = True # False
            kkres = self._kknative.open_connection(self._source_id, address, blocking)
            if kkres.result_code != ErrorCode.KK_NO_ERR:
                self._flagConnected = False
                return False
            self._flagConnected = True
            print('Connected!', flush=True)
            # set to 2 channel mode
            self.send_command(cmds['channel']['2'])
            return True
        else:
            return False

    def disconnect(self):

        if self._flagConnected:
            self._kknative.close_connection(self._source_id)
            self._flagConnected = False
            print('Disconnected!', flush=True)
            return True
        else:
            return False
    
    # Control
    def send_command(self, cmd):

        if self._flagConnected:
            kkres = self._kknative.send_command(self._source_id, cmd)
            if kkres.result_code != ErrorCode.KK_NO_ERR:
                print('Command failed!', flush=True)
                return False
            else:
                return True
        else:
            return False
        
    def read_buffer(self):

        if self._flagConnected:
            kkres = self._kknative.get_report(self._source_id)
            # examine result code
            if kkres.result_code == ErrorCode.KK_ERR_BUFFER_OVERFLOW:
                print("get_report reports overflow error", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_SERVER_DOWN:
                print("get_report reports no connection to TCP server", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_WRITE:
                print("get_report reports write error", flush=True)
            elif kkres.result_code == ErrorCode.KK_ERR_DEVICE_NOT_CONNECTED:
                print("get_report reports unconnected device", flush=True)
            elif kkres.result_code == ErrorCode.KK_HARDWARE_FAULT:
                print("get_report reports hardware fault", flush=True)
            elif ((kkres.result_code != ErrorCode.KK_NO_ERR) and 
                (kkres.result_code != ErrorCode.KK_ERR_BUFFER_TOO_SMALL)):
                print("get_report failed: "+kkres.data, flush=True)
            elif kkres.data is None:
                print('No data', flush=True)

            else:
                #report header
                subS = kkres.data[:4]
                aHeader = int(subS, 16) # HEX!
                if aHeader < 0x7000:
                    ret = [item.strip() for item in kkres.data.split(';')]
                    ret[0] = aHeader
                    return ret
                elif aHeader > 0x7000:
                    ret = [item.strip() for item in kkres.data.split(';')]
                    ret[0] = aHeader
                    return ret
                # ignore empty message (7000)
                else:
                    return None

            return None
        else:
            return None

    # Measurement
    def measure(self):

        if self._flagConnected:
            data = self.read_buffer()
            if data is not None:
                header = data[0]
                if header < 0x7000:
                    try:
                        self._f[0] = float(data[1]) * 1e3
                        self._f[1] = float(data[2]) * 1e3
                        self._conn.send({'cmd': 'data', 'args': self._f})
                    except ValueError:
                        return False
                else:
                    print(data, flush=True)
                    return False
        
            return True
        else:
            return False
    
    def wait(self, timeStart, timeStop):

        to_wait = self._rate - (timeStop - timeStart)
        if to_wait < 0:
            return True
        else:
            time.sleep(to_wait)
            return True
        
class FXEHandlerDummy():

    def __init__(self, q, conn):

        self._q = q
        self._conn = conn

        self._rate = 0.1
        self._f = [0, 0]
        self._fAvg = 0
        self._fOffset = 0

        self._flagConnected = False

        print('Dummy FXE handler initiated!', flush=True)

    def parseFXECommand(self, cmdDict):

        if cmdDict['cmd'] == 'command':
            self.send_command(cmdDict['args'])
        elif cmdDict['cmd'] == 'rate':
            self._rate = cmds_values['rate'][cmdDict['args']]
            self.send_command(cmds['rate'][cmdDict['args']])
            print('Rate changed to {}'.format(cmdDict['args']))
        elif cmdDict['cmd'] == 'mode':
            self.send_command(cmds['mode'][cmdDict['args']])
            print('Mode changed to {}'.format(cmdDict['args']))
        elif cmdDict['cmd'] == 'devices':
            ret = self.enumerate_devices()
            self._conn.send({'cmd': 'devices', 'args': ret})
        elif cmdDict['cmd'] == 'connect':
            self.connect(cmdDict['args'])
            self._conn.send({'cmd': 'connection', 'args': self._flagConnected})
        elif cmdDict['cmd'] == 'disconnect':
            self.disconnect()
            self._conn.send({'cmd': 'connection', 'args': self._flagConnected})

    def queueEmpty(self):

        return self._q.empty()
    
    # Connection
    def enumerate_devices(self):
        
        return ['Dummy']
    
    def connect(self, address):

        if not self._flagConnected:
            self._flagConnected = True
            print('Connected!', flush=True)
            return True
        else:
            return False

    def disconnect(self):

        if self._flagConnected:
            self._flagConnected = False
            print('Disconnected!', flush=True)
            return True
        else:
            return False
    
    # Control
    def send_command(self, cmd):

        if self._flagConnected:
            return True
        else:
            return False
        
    def read_buffer(self):

        if self._flagConnected:
            f1 = 5e6 
            f1 += np.random.normal(0, 0.1)
            f1 += 10*np.sin(np.pi*time.time()) 
            f1 += self._fOffset

            f2 = 5e6 
            f2 += np.random.normal(0, 0.1)
            f2 += 10*np.sin(np.pi*time.time())
            f2 += self._fOffset

            ret = [
                '6000',
                '{:e}'.format(f1),
                '{:e}'.format(f2)
            ]
            return ret
        else:
            return None

    # Measurement
    def measure(self):

        if self._flagConnected:
            data = self.read_buffer()
            if data is not None:
                header = int(data[0], 16)
                if header < 0x7000:
                    try:
                        self._f[0] = float(data[1])
                        self._f[1] = float(data[2])
                        self._fAvg = np.average(self._f)
                        self._conn.send({'cmd': 'data', 'args': self._f})
                    except ValueError:
                        return False
                else:
                    print(data, flush=True)
                    return False
        
            return True
        else:
            return False
    
    def wait(self, timeStart, timeStop):

        to_wait = self._rate - (timeStop - timeStart)
        if to_wait < 0:
            return True
        else:
            time.sleep(to_wait)
            return True

    # Only dummy settings
    def changeOffset(self, offset):

        self._fOffset = offset
